"""
One-off script to parse Results/report.html (generated by Locust) and export CSV files.
Place this script in the project root and run it. It does not modify app.py.
"""
import json
import os
import csv
import stat
from bs4 import BeautifulSoup

HTML_PATH = os.path.join(os.getcwd(), "Results", "report.html")
OUT_DIR = os.path.join(os.getcwd(), "Exported")


def load_template_args_from_html(html_path):
    with open(html_path, "r", encoding="utf-8") as f:
        html_content = f.read()

    soup = BeautifulSoup(html_content, "html.parser")
    template_args = None
    for script in soup.find_all('script'):
        if script.string and 'window.templateArgs = ' in script.string:
            json_str = script.string.split('window.templateArgs = ')[1].split('\n')[0].strip()
            if json_str.endswith(';'):
                json_str = json_str[:-1]
            template_args = json.loads(json_str)
            break

    if not template_args:
        raise RuntimeError("Could not find Locust template args in the HTML report")
    return template_args


def normalize_requests_statistics(template_args):
    requests_statistics = template_args.get('requests_statistics', {})
    if isinstance(requests_statistics, list):
        requests_statistics = {
            stat['name']: {
                'method': stat.get('method', ''),
                'num_requests': stat.get('num_requests', 0),
                'num_failures': stat.get('num_failures', 0),
                'min_response_time': stat.get('min_response_time', 0),
                'max_response_time': stat.get('max_response_time', 0),
                'avg_response_time': stat.get('avg_response_time', 0),
                'median_response_time': stat.get('median_response_time', 0),
                'response_time_percentile_0.95': stat.get('p95', 0),
                'response_time_percentile_0.99': stat.get('p99', 0),
                'current_rps': stat.get('current_rps', 0),
                'current_fail_per_sec': stat.get('current_fail_per_sec', 0),
                'avg_content_length': stat.get('avg_content_length', 0)
            }
            for stat in requests_statistics
            if stat.get('name') != 'Aggregated'
        }
    return requests_statistics


def build_results_dict(template_args):
    requests_statistics = normalize_requests_statistics(template_args)
    results = {
        'metadata': {
            'start_time': template_args.get('start_time', ''),
            'end_time': template_args.get('end_time', ''),
            'host': template_args.get('host', ''),
            'locustfile': template_args.get('locustfile', '')
        },
        'statistics': {
            'requests': {
                name: {
                    'method': stats.get('method', ''),
                    'num_requests': stats.get('num_requests', 0),
                    'num_failures': stats.get('num_failures', 0),
                    'response_times': {
                        'min': stats.get('min_response_time', 0),
                        'max': stats.get('max_response_time', 0),
                        'average': stats.get('avg_response_time', 0),
                        'median': stats.get('median_response_time', 0),
                        'p95': stats.get('response_time_percentile_0.95', 0),
                        'p99': stats.get('response_time_percentile_0.99', 0)
                    },
                    'performance': {
                        'current_rps': stats.get('current_rps', 0),
                        'current_fail_per_sec': stats.get('current_fail_per_sec', 0),
                        'avg_content_length': stats.get('avg_content_length', 0)
                    }
                }
                for name, stats in requests_statistics.items()
                if name != 'Aggregated'
            },
            'failures': [
                {
                    'endpoint': failure.get('name', ''),
                    'method': failure.get('method', ''),
                    'error': failure.get('error', ''),
                    'occurrences': failure.get('occurrences', 0)
                }
                for failure in template_args.get('failures_statistics', [])
            ],
            'exceptions': template_args.get('exceptions_statistics', [])
        },
        'history': [
            {
                'timestamp': entry.get('time', ''),
                'metrics': {
                    'users': entry.get('user_count', 0),
                    'rps': entry.get('current_rps', 0),
                    'failures_per_sec': entry.get('current_fail_per_sec', 0),
                    'avg_response_time': entry.get('total_avg_response_time', 0),
                    'p95_response_time': entry.get('response_time_percentile_0.95', 0)
                }
            }
            for entry in template_args.get('history', [])
        ]
    }
    return results


def write_csv_files(results, out_dir):
    os.makedirs(out_dir, exist_ok=True)

    def ensure_writable(path):
        # If file exists, try to make it writable (Windows may mark files read-only)
        try:
            if os.path.exists(path):
                current_mode = os.stat(path).st_mode
                os.chmod(path, current_mode | stat.S_IWRITE)
        except Exception:
            # If we cannot change permissions, proceed and let open() raise if necessary
            pass

    # metadata
    meta = results.get('metadata', {})
    meta_path = os.path.join(out_dir, 'metadata.csv')
    ensure_writable(meta_path)
    with open(meta_path, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=['start_time', 'end_time', 'host', 'locustfile'])
        writer.writeheader()
        writer.writerow({
            'start_time': meta.get('start_time', ''),
            'end_time': meta.get('end_time', ''),
            'host': meta.get('host', ''),
            'locustfile': meta.get('locustfile', '')
        })

    # requests
    requests_stats = results.get('statistics', {}).get('requests', {})
    requests_path = os.path.join(out_dir, 'requests.csv')
    ensure_writable(requests_path)
    with open(requests_path, 'w', newline='', encoding='utf-8') as f:
        fieldnames = [
            'request_name', 'method', 'num_requests', 'num_failures',
            'min_response_time', 'max_response_time', 'avg_response_time', 'median_response_time',
            'p95', 'p99', 'current_rps', 'current_fail_per_sec', 'avg_content_length'
        ]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for name, stats in requests_stats.items():
            rt = stats.get('response_times', {})
            perf = stats.get('performance', {})
            writer.writerow({
                'request_name': name,
                'method': stats.get('method', ''),
                'num_requests': stats.get('num_requests', 0),
                'num_failures': stats.get('num_failures', 0),
                'min_response_time': rt.get('min', 0),
                'max_response_time': rt.get('max', 0),
                'avg_response_time': rt.get('average', 0),
                'median_response_time': rt.get('median', 0),
                'p95': rt.get('p95', 0) if 'p95' in rt else rt.get('p95', rt.get('response_time_percentile_0.95', 0)),
                'p99': rt.get('p99', 0) if 'p99' in rt else rt.get('response_time_percentile_0.99', 0),
                'current_rps': perf.get('current_rps', 0),
                'current_fail_per_sec': perf.get('current_fail_per_sec', 0),
                'avg_content_length': perf.get('avg_content_length', 0)
            })

    # failures
    failures = results.get('statistics', {}).get('failures', [])
    failures_path = os.path.join(out_dir, 'failures.csv')
    ensure_writable(failures_path)
    with open(failures_path, 'w', newline='', encoding='utf-8') as f:
        fieldnames = ['endpoint', 'method', 'error', 'occurrences']
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for fail in failures:
            writer.writerow({
                'endpoint': fail.get('endpoint', ''),
                'method': fail.get('method', ''),
                'error': fail.get('error', ''),
                'occurrences': fail.get('occurrences', 0)
            })

    # history
    history = results.get('history', [])
    history_path = os.path.join(out_dir, 'history.csv')
    ensure_writable(history_path)
    with open(history_path, 'w', newline='', encoding='utf-8') as f:
        fieldnames = ['timestamp', 'users', 'rps', 'failures_per_sec', 'avg_response_time', 'p95_response_time']
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        for entry in history:
            metrics = entry.get('metrics', {})
            writer.writerow({
                'timestamp': entry.get('timestamp', ''),
                'users': metrics.get('users', 0),
                'rps': metrics.get('rps', 0),
                'failures_per_sec': metrics.get('failures_per_sec', 0),
                'avg_response_time': metrics.get('avg_response_time', 0),
                'p95_response_time': metrics.get('p95_response_time', 0)
            })

    # rawdata: write plain JSON file (rawdata.json)
    rawjson_path = os.path.join(out_dir, 'rawdata.json')
    # ensure directory exists
    os.makedirs(out_dir, exist_ok=True)
    with open(rawjson_path, 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2)
    print(f"Wrote {rawjson_path}")


def write_rawdata_json(results, out_dir):
    """Write only the single-file JSON export named rawdata.json containing the full results JSON."""
    os.makedirs(out_dir, exist_ok=True)
    rawjson_path = os.path.join(out_dir, 'rawdata.json')
    try:
        with open(rawjson_path, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2)
        print(f"Wrote {rawjson_path}")
    except PermissionError:
        alt_path = os.path.join(out_dir, 'rawdata_new.json')
        with open(alt_path, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2)
        print(f"Permission denied for rawdata.json; wrote {alt_path} instead")


if __name__ == '__main__':
    if not os.path.exists(HTML_PATH):
        print(f"HTML report not found at {HTML_PATH}")
        raise SystemExit(1)

    template = load_template_args_from_html(HTML_PATH)
    results = build_results_dict(template)
    try:
        write_csv_files(results, OUT_DIR)
        print(f"Exported CSV files to {OUT_DIR}")
    except PermissionError as e:
        print(f"PermissionError while writing full CSVs: {e}. Falling back to writing only rawdata.json")
        write_rawdata_json(results, OUT_DIR)
